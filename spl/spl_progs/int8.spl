alias process_table_entry R4;
process_table_entry = PROCESS_TABLE + [SYSTEM_STATUS_TABLE + 1]*16;

// set MODE FLAG (in PROCESS TABLE) to syscall number
[process_table_entry + 9] = 8;

// store value of userSP in R0
alias userSP R0;
userSP = SP;

// switch to kernel stack
[process_table_entry + 13] = SP;
SP = [process_table_entry + 11]*512 - 1;

alias newPID R1;

// get newPID from getPCBEntry
multipush(R0, R4);
R1 = 1;
call PROCESS_MANAGER;
newPID = R0;
multipop(R0, R4);

if (newPID == -1) then
    // no free PID
    [process_table_entry + 9] = 0;
    SP = userSP;
    [[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = -1;
    ireturn;
endif;

if ([PTBR+4] == -1) then
    // parent has no heap
    multipush(R0, R1, R4);
    R1 = 1;
    call MEMORY_MANAGER;
    [PTBR+4] = R0;
    [PTBR+5] = "0110";
    call MEMORY_MANAGER;
    [PTBR+6] = R0;
    [PTBR+7] = "0110";
    multipop(R0, R1, R4);
endif;

// child pagetb
alias newptb R5;
newptb = PAGE_TABLE_BASE + 20*newPID;

// library
[newptb] = [PTBR];
[newptb+1] = "0100";
[newptb+2] = [PTBR+2];
[newptb+3] = "0100";
[MEMORY_FREE_LIST + [PTBR]] = [MEMORY_FREE_LIST + [PTBR]] + 1;
[MEMORY_FREE_LIST + [PTBR+2]] = [MEMORY_FREE_LIST + [PTBR+2]] + 1;

// heap
[newptb+4] = [PTBR+4];
[newptb+5] = "0110";
[newptb+6] = [PTBR+6];
[newptb+7] = "0110";
[MEMORY_FREE_LIST + [PTBR+4]] = [MEMORY_FREE_LIST + [PTBR+4]] + 1;
[MEMORY_FREE_LIST + [PTBR+6]] = [MEMORY_FREE_LIST + [PTBR+6]] + 1;

// code
[newptb+8] = [PTBR+8];
[newptb+9] = "0100";
[newptb+10] = [PTBR+10];
[newptb+11] = [PTBR+11];
[newptb+12] = [PTBR+12];
[newptb+13] = [PTBR+13];
[newptb+14] = [PTBR+14];
[newptb+15] = [PTBR+15];
[MEMORY_FREE_LIST + [PTBR+8]] = [MEMORY_FREE_LIST + [PTBR+8]] + 1;
[MEMORY_FREE_LIST + [PTBR+10]] = [MEMORY_FREE_LIST + [PTBR+10]] + 1;
[MEMORY_FREE_LIST + [PTBR+12]] = [MEMORY_FREE_LIST + [PTBR+12]] + 1;
[MEMORY_FREE_LIST + [PTBR+14]] = [MEMORY_FREE_LIST + [PTBR+14]] + 1;

// stack
multipush(R0, R1, R4, R5);
R1 = 1;
call MEMORY_MANAGER;
multipop(R5);
[newptb+16] = R0;
[newptb+17] = "0110";
multipush(R5);
call MEMORY_MANAGER;
multipop(R5);
[newptb+18] = R0;
[newptb+19] = "0110";

// UAPage
multipush(R5);
call MEMORY_MANAGER;
multipop(R1, R4, R5);
[PROCESS_TABLE + newPID*16 + 11] = R0;
multipop(R0);

// child proctb
alias process_table_new R2;
process_table_new = PROCESS_TABLE + newPID*16;
[process_table_new] = 0;
[process_table_new+2] = [SYSTEM_STATUS_TABLE+1];
[process_table_new+3] = [process_table_entry+3];
[process_table_new+4] = CREATED;
[process_table_new+6] = [process_table_entry+6];
[process_table_new+7] = [process_table_entry+7];
[process_table_new+9] = 0;
[process_table_new+10] = [process_table_entry+10];
[process_table_new+12] = 0;
[process_table_new+13] = userSP;


// copy per-process resource table
alias i R3;
alias l R6;
alias j R7;
i = [process_table_new+11]*512 + 496;
l = i + 16;
j = [process_table_entry+11]*512 + 496;
while (i < l) do
    [i] = [j];
    i = i + 1;
    j = j + 1;
endwhile;

// copy disk map table
i = DISK_MAP_TABLE + newPID*10;
l = i + 10;
j = DISK_MAP_TABLE + [SYSTEM_STATUS_TABLE+1]*10;
while (i < l) do
    [i] = [j];
    i = i + 1;
    j = j + 1;
endwhile;

// copy stack page 1
i = [newptb+16]*512;
l = i + 512;
j = [PTBR+16]*512;
while (i < l) do
    [i] = [j];
    i = i + 1;
    j = j + 1;
endwhile;

// copy stack page 2
i = [newptb+18]*512;
l = i + 512;
j = [PTBR+18]*512;
while (i < l) do
    [i] = [j];
    i = i + 1;
    j = j + 1;
endwhile;

// push BP
[[process_table_new + 11]*512] = BP;
[[PTBR + 2*(userSP-1)/512]*512 + (userSP-1)%512] = newPID;
[[newptb + 2*(userSP-1)/512]*512 + (userSP-1)%512] = 0;

// reset mode flag
[process_table_entry + 9] = 0;

// switch to user stack
SP = userSP;

ireturn;