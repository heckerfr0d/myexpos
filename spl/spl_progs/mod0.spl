// RESOURCE_MANAGER
alias functionNum R1;
alias currentPID R2;

if(functionNum == ACQUIRE_DISK) then
    while([DISK_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + 16*currentPID + 4] = WAIT_DISK;
        multipush(R1,R2);
        call SCHEDULER;
        multipop(R1,R2);
    endwhile;
    [DISK_STATUS_TABLE] = 1;
    [DISK_STATUS_TABLE + 4] = currentPID;
    return;
endif;

if(functionNum == ACQUIRE_TERMINAL) then
    while([TERMINAL_STATUS_TABLE] == 1) do
        [PROCESS_TABLE + 16*currentPID + 4]=WAIT_TERMINAL;
        multipush(R1,R2);

        call SCHEDULER;

        multipop(R1,R2);
    endwhile;
    [TERMINAL_STATUS_TABLE] = 1;
    [TERMINAL_STATUS_TABLE + 1] = currentPID;
    //breakpoint;
    return;
endif;

if(functionNum == RELEASE_TERMINAL) then
    if(currentPID == [TERMINAL_STATUS_TABLE+1]) then
        [TERMINAL_STATUS_TABLE]=0;
        alias i R3;
        i = PROCESS_TABLE + 20;
        while(i < PROCESS_TABLE+256) do
            if([i] == WAIT_TERMINAL) then
                [i] = READY;
            endif;
            i=i+16;
        endwhile;
        R0=0;
        // breakpoint;
        return;
    else
        R0=-1;
        // breakpoint;
        return;
    endif;

endif;

if (functionNum == ACQUIRE_INODE) then
    alias fid R3;
    alias fst R4;
    fst = FILE_STATUS_TABLE + fid*4;
    while([fst] != -1 && [fst] != [SYSTEM_STATUS_TABLE+1]) do
        [PROCESS_TABLE + 16*currentPID + 4] = WAIT_FILE;
        [PROCESS_TABLE + 16*currentPID + 5] = fid;
        multipush(R1, R2, R3);
        call SCHEDULER;
        multipop(R1, R2, R3);
    endwhile;
    if ([INODE_TABLE + fid*16 + 1]==-1) then
        R0 = -1;
        return;
    endif;
    [fst] = currentPID;
    R0 = 0;
    return;
endif;

if (functionNum == RELEASE_INODE) then
    // release inode
    alias fid R3;
    alias fst R4;
    fst = FILE_STATUS_TABLE + currentPID*4;
    if ([fst]!=currentPID) then
        R0 = -1;
        return;
    endif;

    [fst] = -1;
    alias i R5;
    i = PROCESS_TABLE + 20;
    while (i<PROCESS_TABLE+256) do
        if ([i]==WAIT_FILE && [i+1]==fid) then
            [i] = READY;
        endif;
        i = i + 16;
    endwhile;
    R0 = 0;
    return;
endif;

if (functionNum == 6) then
    // acquire semaphore
    alias i R0;
    alias n R3;
    i = SEMAPHORE_TABLE + 1;
    n = SEMAPHORE_TABLE + 128;
    while (i < n) do
        if ([i]==0) then
            [i] = 1;
            [i-1] = -1;
            R0 = (i - SEMAPHORE_TABLE - 1)/4;
            return;
        endif;
        i = i + 4;
    endwhile;
    R0 = -1;
    return;
endif;

if (functionNum == 7) then
    // release semaphore
    alias semid R3;
    alias sem_entry R4;
    sem_entry = SEMAPHORE_TABLE + semid*4;
    if ([sem_entry]==currentPID) then
        [sem_entry] = -1;
        alias i R5;
        i = PROCESS_TABLE + 20;
        while (i<PROCESS_TABLE+256) do
            if ([i]==WAIT_SEMAPHORE && [i+1]==semid) then
                [i] = READY;
            endif;
            i = i + 16;
        endwhile;
    else
        if ([sem_entry]!=-1 || [sem_entry+1]==0) then
            R0 = -1;
            return;
        endif;
    endif;
    [sem_entry+1] = [sem_entry+1] - 1;
    R0 = 0;
    return;
endif;
