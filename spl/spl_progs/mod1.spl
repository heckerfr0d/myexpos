alias functionNum R1;
alias currentPID R2;

if (functionNum == FREE_USER_AREA_PAGE) then
    // free UAPage
    multipush(R1, R2);
    R1 = 2;
    R2 = [PROCESS_TABLE + currentPID*16 + 11];
    call MEMORY_MANAGER;
    multipop(R1, R2);

    return;
endif;

if (functionNum == EXIT_PROCESS) then
    // exit
    multipush(R1, R2);

    // free pageTable
    R1 = 4;
    call PROCESS_MANAGER;

    // free UAPage
    R1 = 2;
    call PROCESS_MANAGER;

    multipop(R1, R2);

    [PROCESS_TABLE + currentPID*16 + 4] = TERMINATED;
    return;
endif;

if (functionNum == FREE_PAGE_TABLE) then
    // free pageTable
    [PTBR + 0] = -1;
    [PTBR + 1] = "0000";
    [PTBR + 2] = -1;
    [PTBR + 3] = "0000";

    alias pageTable R3;
    pageTable = PTBR + 4;
    while (pageTable < PTBR+20) do

        multipush(R1, R2, R3);
        R1 = 2;
        R2 = [pageTable];
        call MEMORY_MANAGER;
        multipop(R1, R2, R3);

        [pageTable] = -1;
        [pageTable + 1] = "0000";
        pageTable = pageTable + 2;
    endwhile;

    // Release stack,heap blocks 
    // Invalidate disk_map_table entries
    alias disk_map R4;
    disk_map = DISK_MAP_TABLE + R2*10;
    alias i R3;
    i=2;
    while( i<10 ) do
        if( [disk_map + i] != -1 && ( i==2 || i==3 || i==8 || i==9 )) then
            // RELEASE_BLOCK
            multipush(R1,R2,R3,R4);
            R1 = 4;
            R3 = R2;
            R2 = [disk_map + i];
            call MEMORY_MANAGER;
            multipush(R1,R2,R3,R4);
        endif;
        [disk_map + i]=-1;
        i=i+1;
    endwhile;

    return;
endif;